//////////////////////////////////////////////////////////////////////////////////////////////////
/*
*		Игра "Математико" - это итальянская логическая игра. Правила игры довольно просты. 
*		В ней могут принимать участие неограниченное количество человек.
*
*		Готовится набор из 52 карточек, на которых записаны числа от 1 до 13, 
*	причем карточки с каждым из этих чисел встречаются четырежды.
*
*		У каждого игрока имеется квадратное поле с 25 клетками.  
*
*		Ведущий берет колоду приготовленных карточек с числами, растасовывает ее
*	(или раскладывает их на столе, числами вниз), затем открывает первую карточку и объявляет 
*	написанное на ней число.
*		Каждый из играющих записывает это число в одну из клеток на своем поле. 
*		Затем ведущий объявляет число, написанное на следующей карточке,
*	играющие опять вписывают его в любую из свободных клеток своего листа и т. д. 
*		Так продолжается до тех пор, пока не будут заполнены все клетки квадрата.
*
*		Результат игрока оценивается числом набранных им очков, зависящим от 
*	способа размещения чисел в клетках квадрата.
*		Победителем считается тот, кто набирает наибольшее количество очков.
*
*+--------------------------------------------------------------------------+-----------------------+-------------+
*|							Комбинации чисел								|	В ряду или столбце	| По диагонали|
*+--------------------------------------------------------------------------+-----------------------+-------------|
*|	За 2 одинаковых числа													|		10 очков		|  20 очков	  |
*|	За 2 пары одинаковых чисел												|		20 очков		|  30 очков	  |
*|	За 3 одинаковых числа													|		40 очков		|  50 очков	  |
*|	За 3 одинаковых числа и два других одинаковых числа						|		80 очков		|  90 очков	  |
*|	За 4 одинаковых числа													|		160 очков		|  170 очков  |
*|	За 5 последовательных чисел, но не обязательно по порядку расположенных	|		50 очков		|  60 очков	  |
*|	За три раза по 1 и два раза по 13										|		100 очков		|  110 очков  |
*|	За числа 1, 13, 12, 11 и 10, но не обязательно по порядку расположенных	|		150 очков		|  160 очков  |
*|	За 4 единицы															|		200 очков		|  210 очков  |
*+--------------------------------------------------------------------------+-----------------------+-------------+
*/
//////////////////////////////////////////////////////////////////////////////////////////////////
	#include <algorithm>
	#include <vector>
	#include <time.h>
	#include <stdio.h>
	#include <stdlib.h>
	#include <iostream>
//////////////////////////////////////////////////////////////////////////////////////////////////
//	#pragma hdrstop //раскомпилить если жрёт много оперативы
/*	#pragma hdrstop
*	аналог PCH - все заинклуденные хаэдеры до 
*	#pragma hdrstop будут прекомпилированы и закешены, если где еще в 
*	CPP файлах компилятор встретит ту же последовательность хэадеров до #pragma hdrstop - 
*	то заюзается уже скомпиленый кеш.
*	Для этого есть и нормальные вещи, но мне лень гуглить что-либо-нибудь-кое.
*/
//////////////////////////////////////////////////////////////////////////////////////////////////
	using namespace std;
//////////////////////////////////////////////////////////////////////////////////////////////////
/*Если игра идёт*/
	bool isGame;

/*Если игра с компьютером*/
	bool isComputer;

/*Для юзверя*/
	int arrPoleUser[5][5];

/*Для компа*/
	int arrPoleComp[5][5];
	std::vector<int> vCards;
	int currentCard;
//////////////////////////////////////////////////////////////////////////////////////////////////
/*Пользователь записывает номер в ячейку (счёт nCol и nRow ведётся с единицы)*/
	//bool WriteCardIntoUserCell(int nCol, int nRow);

/*Для карт*/
	//void ReCreateCards();
	int scores(int numbers[5], bool bDiagonal);
	int totalScores(int pole[5][5]);

/*Проверка на 4 единицы*/
	bool checkForOnce(const int *numbers);

/*Проверка на  1, 13, 12, 11 и 10*/
	bool check113121110(const int *numbers);

/*Проверка на числа 1 и 13*/
	bool check113(const int *numbers);

/*Проверка на последовательные числа*/
	bool checkSerialNumbers(const int *numbers);

/*Проверка на одинаковые числа*/
	bool checkIdenticalNumbers(const int *numbers, int n1 = 4, int n2 = 0);
//////////////////////////////////////////////////////////////////////////////////////////////////
	struct stuctMax{
		int MaxX;
		int MaxY;
	};
//////////////////////////////////////////////////////////////////////////////////////////////////
int main() {
	setlocale(0,"");
/*Тестовый массив*/
		int arr[5][5] = { {10, 8, 5, 2, 6},
		{11, 8, 5, 11, 12},
		{9, 3, 3, 3, 9},
		{12, 6, 7, 2, 12},
		{1, 1, 1, 1, 9} };
		cout<<totalScores(arr);
	return 0;
}
//////////////////////////////////////////////////////////////////////////////////////////////////
int totalScores(int Pole[5][5]){
		int totalScores = 0;

/*Проходим столбцы*/
		for (int x = 0; x < 5; x++) {
			int numbers[5];
			for (int y = 0; y < 5; y++) {
				numbers[y] = Pole[x][y];
			}
			totalScores += scores(numbers, false);
		}

/*Проходим строки*/
		for (int y = 0; y < 5; y++) {
			int numbers[5];
			for (int x = 0; x < 5; x++) {
				numbers[x] = Pole[x][y];
			}
			totalScores += scores(numbers, false);
		}

/*Проходим диагонали*/
		int numbers[5];
		for (int i = 0; i < 5; i++) {
			numbers[i] = Pole[i][i];
		}
		totalScores += scores(numbers, true);
		for (int i = 0; i < 5; i++) {
			numbers[i] = Pole[4 - i][i];
		}
		totalScores += scores(numbers, true);

	return totalScores;
}
//////////////////////////////////////////////////////////////////////////////////////////////////
int scores(int numbers[5], bool bDiagonal){
		std::sort(numbers, numbers + 5);

/*Проверка на 4 единицы*/
		if (checkForOnce(numbers)) { if (bDiagonal) return 210; else return 200; }

/*Проверка на числа 1, 13, 12, 11 и 10*/
		else if (check113121110(numbers)) { if (bDiagonal) return 160; else return 150; }

/*Проверка на числа 1, 13*/
		else if (check113(numbers)) { if (bDiagonal) return 110; else return 100; }

/*Проверка на последовательные числа*/
		else if (checkSerialNumbers(numbers)) { if (bDiagonal) return 60; else return 50; }
		else if (checkIdenticalNumbers(numbers, 4, 0)) { if (bDiagonal) return 170; else return 160; }
		else if (checkIdenticalNumbers(numbers, 3, 2)) { if (bDiagonal) return 90; else return 80; }
		else if (checkIdenticalNumbers(numbers, 3, 0)) { if (bDiagonal) return 50; else return 40; }
		else if (checkIdenticalNumbers(numbers, 2, 2)) { if (bDiagonal) return 30; else return 20; }
		else if (checkIdenticalNumbers(numbers, 2, 0)) { if (bDiagonal) return 20; else return 10; }

	return 0;
}
//////////////////////////////////////////////////////////////////////////////////////////////////
/*Проверка на 4 единицы*/
bool checkForOnce(const int *numbers){
		int arr[] = { 1,1,1,1 };
		if (memcmp(numbers, arr, sizeof(arr)) == 0 ||

/*Ниже строка для ИИ*/
			memcmp(&numbers[1], arr, sizeof(arr)) == 0) return true; 

	return false;
}
//////////////////////////////////////////////////////////////////////////////////////////////////
/*Проверка на  1, 13, 12, 11 и 10*/
bool check113121110(const int *numbers){
		int arr[] = { 1,10,11,12,13 };

		if (memcmp(numbers, arr, sizeof(arr)) == 0) return true;

	return false;
}
//////////////////////////////////////////////////////////////////////////////////////////////////
/*Проверка на числа 1 и 13*/
bool check113(const int *numbers){ 
		int arr[] = { 1,1,1,13,13 };

		if (memcmp(numbers, arr, sizeof(arr)) == 0) return true;

	return false;
}
//////////////////////////////////////////////////////////////////////////////////////////////////
/*Проверка на последовательные числа*/
bool checkSerialNumbers(const int *numbers){

		for (int i = 1; i < 5; i++){
			if (numbers[i] - numbers[i - 1] != 1) return false;
		}

	return true;
}
//////////////////////////////////////////////////////////////////////////////////////////////////
/*Проверка на одинаковые числа*/
bool checkIdenticalNumbers(const int *numbers, int n1, int n2){
		int next = 0;
		int count[2] = { 0 };

		for (int i = 1; i < 5; i++){
			if (numbers[i] == 0 || numbers[i - 1] == 0) continue;

			if (numbers[i] == numbers[i - 1]) count[next]++;
			else if (count[next] != 0) next++;
		}

		if (count[0]) count[0]++;
		if (count[1]) count[1]++;
		if ((count[0] >= n1 && count[1] >= n2) ||
			(count[1] >= n1 && count[0] >= n2)) return true;

	return false;
}
//////////////////////////////////////////////////////////////////////////////////////////////////